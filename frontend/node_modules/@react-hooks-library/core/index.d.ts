import * as _react_hooks_library_shared from '@react-hooks-library/shared';
import { MaybeRef, Fn } from '@react-hooks-library/shared';
import * as react from 'react';
import { Dispatch, SetStateAction } from 'react';

/**
 * Breakpoints from Tailwind V2
 *
 * @see https://tailwindcss.com/docs/breakpoints
 */
declare const breakpointsTailwind: {
    sm: number;
    md: number;
    lg: number;
    xl: number;
    '2xl': number;
};
/**
 * Breakpoints from Bootstrap V5
 *
 * @see https://getbootstrap.com/docs/5.0/layout/breakpoints
 */
declare const breakpointsBootstrapV5: {
    sm: number;
    md: number;
    lg: number;
    xl: number;
    xxl: number;
};
/**
 * Breakpoints from Vuetify V2
 *
 * @see https://vuetifyjs.com/en/features/breakpoints
 */
declare const breakpointsVuetify: {
    xs: number;
    sm: number;
    md: number;
    lg: number;
};
/**
 * Breakpoints from Ant Design
 *
 * @see https://ant.design/components/layout/#breakpoint-width
 */
declare const breakpointsAntDesign: {
    xs: number;
    sm: number;
    md: number;
    lg: number;
    xl: number;
    xxl: number;
};
/**
 * Sematic Breakpoints
 */
declare const breakpointsSematic: {
    mobileS: number;
    mobileM: number;
    mobileL: number;
    tablet: number;
    laptop: number;
    laptopL: number;
    desktop4K: number;
};

/**
 * Reactive hooks and utilities to be used with user provided breakpoints.
 *
 * @param {string} breakpoints
 * @returns functions to be used as hooks
 *
 * @see https://react-hooks-library.vercel.app/core/BreakPointHooks
 */
declare function BreakPointHooks<BreakPoints extends Record<string, number>>(breakpoints: BreakPoints): {
    /**
     * Hook that returns a boolean if screen width is greater than given breakpoint.
     *
     * @param k {string} breakpoint
     * @returns boolean
     *
     * @see https://react-hooks-library.vercel.app/core/BreakPointHooks
     **/
    useGreater: (k: keyof BreakPoints) => boolean;
    /**
     * Hook that returns a boolean if screen width is smaller than given breakpoint.
     *
     * @param k {string} breakpoint
     * @param k {string} breakpoint
     *
     * @returns boolean
     *
     * @see https://react-hooks-library.vercel.app/core/BreakPointHooks
     **/
    useSmaller: (k: keyof BreakPoints) => boolean;
    /**
     * Hook that returns a boolean if screen width is between two given breakpoint.
     *
     * @param a {string} breakpoint
     * @param b {string} breakpoint
     *
     * @returns boolean
     *
     * @see https://react-hooks-library.vercel.app/core/BreakPointHooks
     **/
    useBetween: (a: keyof BreakPoints, b: keyof BreakPoints) => boolean;
    /**
     * Utility function that returns a boolean if screen width is greater than given breakpoint.
     *
     * @param k {string} breakpoint
     *
     * @see https://react-hooks-library.vercel.app/core/BreakPointHooks
     **/
    isGreater(k: keyof BreakPoints): boolean;
    /**
     * Utility function that returns a boolean if screen width is smaller than given breakpoint.
     *
     * @param k {string} breakpoint
     *
     * @see https://react-hooks-library.vercel.app/core/BreakPointHooks
     **/
    isSmaller(k: keyof BreakPoints): boolean;
    /**
     * Utility function that returns a boolean if screen width is between two given breakpoint.
     *
     * @param k {string} breakpoint
     *
     * @see https://react-hooks-library.vercel.app/core/BreakPointHooks
     **/
    isInBetween(a: keyof BreakPoints, b: keyof BreakPoints): boolean;
};
declare type BreakPointHooksReturn = ReturnType<typeof BreakPointHooks>;

/**
 * Reactive document.activeElement, returns a reference to current active element
 *
 * @returns current active element (DOM node)
 **/
declare function useActiveElement(): {
    activeElement: Element | null | undefined;
};

declare type UseAsyncState<T> = {
    data: T | undefined;
    error: boolean;
    isSuccess: boolean;
    isLoading: boolean;
};
/**
 * Returns a current execution state of an async function.
 * Use it to orchestrate async actions in UI.
 *
 * @see https://react-hooks-library.vercel.app/core/useAsyncCallback
 */
declare function useAsyncCallback<Args extends unknown[], ResolvedType>(callback: (...args: Args) => Promise<ResolvedType>): [UseAsyncState<ResolvedType>, (...args: Args) => Promise<ResolvedType>];

declare type ClickOutsideEvents = Pick<WindowEventMap, 'mousedown' | 'mouseup' | 'touchstart' | 'touchend' | 'pointerdown' | 'pointerup'>;
interface ClickOutsideOptions<E extends keyof ClickOutsideEvents> {
    event?: E;
}
/**
 * Listen for clicks outside of an element.
 *
 * @param target
 * @param handler
 * @param options
 *
 * @see https://react-hooks-library.vercel.app/core/onClickOutside
 */
declare function useClickOutside<E extends keyof ClickOutsideEvents = 'pointerdown'>(target: MaybeRef<Element | null | undefined>, handler: (evt: ClickOutsideEvents[E]) => void, options?: ClickOutsideOptions<E>): _react_hooks_library_shared.Fn;

/**
 * Used to debounce a quickly changing value.
 * Will return the latest value after a specified amount of time.
 *
 * @param {T} value
 * @param timeout
 * @returns {Readonly<T>} latest value
 * @see https://react-hooks-library.vercel.app/core/useDebounce
 */
declare function useDebounce<T>(value: T, timeout: number): Readonly<T>;

/**
 * A useEffect hook does that not run on mount, but only on subsequent updates.
 *
 * @deprecated This hook breaks in React 18's strict mode, since it's not idempotent
 *
 * @param effect
 * @param deps
 *
 * @see https://react-hooks-library.vercel.app/core/useEffectAfterMount
 */
declare function useEffectAfterMount(effect: React.EffectCallback, deps?: React.DependencyList | undefined): void;

interface InferEventTarget<Events> {
    addEventListener(event: Events, fn?: any, options?: any): any;
    removeEventListener(event: Events, fn?: any, options?: any): any;
}
declare type WindowEventName = keyof WindowEventMap;
declare type DocumentEventName = keyof DocumentEventMap;
declare type GeneralEventListener<E = Event> = {
    (evt: E): void;
};
/**
 * Register listener using addEventListener when mounting, and removeEventListener automatically when un-mounting.
 *
 * Returns a cleanup function manually if you want to remove the listener manually.
 *
 * Overload 1: Omitted Window target
 *
 * @see https://react-hooks-library.vercel.app/core/useEventListener
 * @param event
 * @param listener
 * @param options
 * @returns Clean up function for manual cleanup
 */
declare function useEventListener<E extends keyof WindowEventMap>(event: E, listener: (this: Window, ev: WindowEventMap[E]) => any, options?: boolean | AddEventListenerOptions): Fn;
/**
 * Register listener using addEventListener when mounting, and removeEventListener automatically when un-mounting.
 *
 * Returns a cleanup function manually if you want to remove the listener manually.
 *
 * Overload 2: Explicitly Window target
 *
 * @see https://react-hooks-library.vercel.app/core/useEventListener
 * @param target
 * @param event
 * @param listener
 * @param options
 * @returns Clean up function for manual cleanup
 */
declare function useEventListener<E extends keyof WindowEventMap>(target: Window, event: E, listener: (this: Window, ev: WindowEventMap[E]) => any, options?: boolean | AddEventListenerOptions): Fn;
/**
 * Register listener using addEventListener when mounting, and removeEventListener automatically when un-mounting.
 *
 * Returns a cleanup function manually if you want to remove the listener manually.
 *
 * Overload 3: Explicitly Document target
 *
 * @see https://react-hooks-library.vercel.app/core/useEventListener
 * @param target
 * @param event
 * @param listener
 * @param options
 * @returns Clean up function for manual cleanup
 */
declare function useEventListener<E extends keyof DocumentEventMap>(target: Document, event: E, listener: (this: Document, ev: DocumentEventMap[E]) => any, options?: boolean | AddEventListenerOptions): Fn;
/**
 * Register listener using addEventListener when mounting, and removeEventListener automatically when un-mounting.
 *
 * Returns a cleanup function manually if you want to remove the listener manually.
 *
 * Overload 4: Custom event target with event type infer
 *
 * @see https://react-hooks-library.vercel.app/core/useEventListener
 * @param target
 * @param event
 * @param listener
 * @param options
 * @returns Clean up function for manual cleanup
 */
declare function useEventListener<Names extends string, EventType = Event>(target: InferEventTarget<Names>, event: Names, listener: GeneralEventListener<EventType>, options?: boolean | AddEventListenerOptions): Fn;
/**
 * Register listener using addEventListener when mounting, and removeEventListener automatically when un-mounting.
 *
 * Returns a cleanup function manually if you want to remove the listener manually.
 *
 * Overload 5: Custom event target fallback
 *
 * @see https://react-hooks-library.vercel.app/core/useEventListener
 * @param target
 * @param event
 * @param listener
 * @param options
 * @returns Clean up function for manual cleanup
 */
declare function useEventListener<EventType = Event>(target: MaybeRef<EventTarget | null | undefined>, event: string, listener: GeneralEventListener<EventType>, options?: boolean | AddEventListenerOptions): Fn;

/**
 * React FontFace, a hook to load fonts asynchronously
 *
 * @param family
 * @param source
 * @param descriptors
 *
 * @see https://react-hooks-library.vercel.app/core/useFont
 */
declare function useFont(family: string, source: string | Blob, descriptors?: FontFaceDescriptors): {
    loaded: boolean;
    error: boolean;
    font: FontFace | null;
};

/**
 * Hook that returns whether or not the component has mounted.
 * Useful in SSR frameworks like Next or Gatsby.
 *
 * @returns hasMounted
 */
declare function useHasMounted(): boolean;

/**
 *
 * Detect if a dom element is hovered
 *
 * @param target - The element to listen to
 * @returns
 */
declare function useHover(target: MaybeRef<EventTarget | null>): boolean;

interface IntersectionObserverOptions {
    /**
     * The Element or Document whose bounds are used as the bounding box when testing for intersection.
     *
     * @default document
     */
    root?: MaybeRef<Element | Document | undefined | null>;
    /**
     * A string which specifies a set of offsets to add to the root's bounding_box when calculating intersections.
     *
     * @default '0px'
     */
    rootMargin?: string;
    /**
     * Either a single number or an array of numbers between 0.0 and 1.
     *
     * @default 0
     */
    threshold?: number | number[];
}
/**
 * Reactive intersection observer.
 *
 * @param target - React ref or DOM node
 * @param options - Options passed to mutation observer
 * @param callback - callback to execute when mutations are observed
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver IntersectionObserver MDN
 * @see https://react-hooks-library.vercel.app/core/useIntersectionObserver
 */
declare function useIntersectionObserver(target: MaybeRef<Element | undefined | null>, options?: IntersectionObserverOptions, callback?: IntersectionObserverCallback): {
    isSupported: boolean;
    stop: () => void;
    inView: boolean;
    entry: IntersectionObserverEntry | null;
};

declare type UseIntervalOptions = {
    immediate: boolean;
    paused: boolean;
};
/**
 * Run a function repeatedly at a specified interval.
 *
 * @see https://react-hooks-library.vercel.app/core/useInterval
 */
declare function useInterval<T extends () => void>(callback: T, delay: number, options?: Partial<UseIntervalOptions>): void;

/**
 * Is a feature supported in the browser or not
 *
 * @param predicate - predicate to check if the feature is supported
 *
 * @see https://react-hooks-library.vercel.app/core/useIsSupported
 */
declare function useIsSupported(predicate: () => boolean): boolean;

declare type Keys = string | string[];
declare type KeyStrokeEventName = 'keydown' | 'keypress' | 'keyup';
declare type KeyStrokeOptions = {
    /** Key Stroke Event Name
     *
     * Can only be one of the following:
     *  - keydown
     *  - keypress
     *  - keyup
     */
    eventName?: KeyStrokeEventName;
    /** The DOM node to attach the event listener to
     * @default window
     */
    target?: MaybeRef<EventTarget>;
    /**
     * when `true` will use `event.code`
     *
     * when `false` will use `event.key`
     *
     * @default false
     */
    code?: boolean;
    /** TA boolean value that, if true,
     * indicates that the function specified by listener
     * will never call `preventDefault()`.
     *
     * @default window
     */
    passive?: false;
};
/**
 * Listen for keyboard keys being stroked.
 *
 * @param keys
 * @param handler
 * @param options
 *
 * @see https://react-hooks-library.vercel.app/core/useKeyStroke
 */
declare function useKeyStroke(keys: Keys, handler: (event: KeyboardEvent) => void, options?: KeyStrokeOptions): _react_hooks_library_shared.Fn;
/**
 * Listen for keyboard keys on keydown.
 *
 * @param keys
 * @param handler
 * @param options
 *
 * @see https://react-hooks-library.vercel.app/core/useKeyStroke
 */
declare function useKeyDown(keys: Keys, handler: (event: KeyboardEvent) => void, options?: KeyStrokeOptions): _react_hooks_library_shared.Fn;
/**
 * Listen for keyboard keys on keypress.
 *
 * @param keys
 * @param handler
 * @param options
 *
 * @see https://react-hooks-library.vercel.app/core/onKeyStroke
 */
declare function useKeyPressed(keys: Keys, handler: (event: KeyboardEvent) => void, options?: KeyStrokeOptions): _react_hooks_library_shared.Fn;
/**
 * Listen for keyboard keys on keyup.
 *
 * @param keys
 * @param handler
 * @param options
 *
 * @see https://react-hooks-library.vercel.app/core/onKeyStroke
 */
declare function useKeyUp(keys: Keys, handler: (event: KeyboardEvent) => void, options?: KeyStrokeOptions): _react_hooks_library_shared.Fn;

declare type UseLocalStorageOptions = {
    /**
     * Function for converting to string.
     *
     * @default JSON.stringify
     */
    serialize: (value: unknown) => string;
    /**
     * Function to convert stored string to object value.
     *
     * @default JSON.parse
     */
    deserialize: (value: string) => unknown;
};
/**
 * Modified `useState` hook that syncs with localStorage.
 *
 * @param key
 * @param initialValue
 * @param options
 *
 * @see https://react-hooks-library.vercel.app/core/useLocalStorage
 */
declare function useLocalStorage<T>(key: string, initialValue: T, options?: UseLocalStorageOptions): [T, (value: T) => void];

interface Location {
    trigger: string;
    state?: any;
    length?: number;
    hash?: string;
    host?: string;
    hostname?: string;
    href?: string;
    origin?: string;
    pathname?: string;
    port?: string;
    protocol?: string;
    search?: string;
}
/**
 * Reactive browser location.
 *
 * @see https://react-hooks-library.vercel.app/core/useLocation
 *
 */
declare function useLocation(): Location | null;

/**
 * Reactive media query hook that returns the truthy value of the media query.
 *
 * @param {string} query
 * @returns {boolean} boolean value of the query
 *
 * @see https://react-hooks-library.vercel.app/core/useMediaQuery
 */
declare function useMediaQuery(query: string): boolean;

interface UseMediaStreamOptions {
    /**
     * Recreate stream when the input devices id changed
     *
     * @default true
     */
    autoSwitch?: boolean;
    /**
     * The device id of video input
     *
     * When passing with `undefined` the default device will be used.
     * Pass `false` or "none" to disabled video input
     *
     * @default undefined
     */
    videoDeviceId?: string | undefined | false | 'none';
    /**
     * The device id of audio input
     *
     * When passing with `undefined` the default device will be used.
     * Pass `false` or "none" to disabled audio input
     *
     * @default undefined
     */
    audioDeviceId?: string | undefined | false | 'none';
}
/**
 * Reactive `mediaDevices.getUserMedia` streaming
 *
 * @param options
 *
 * @see https://react-hooks-library.vercel.app/core/useMediaStream
 */
declare function useMediaStream(options?: UseMediaStreamOptions): {
    isSupported: boolean;
    ref: react.MutableRefObject<HTMLVideoElement | null>;
    stream: react.MutableRefObject<MediaStream | null>;
    isPlaying: boolean;
    play: () => Promise<MediaStream | null | undefined>;
    stop: () => void;
    restart: () => Promise<MediaStream | null | undefined>;
    isAudioMuted: boolean;
    muteAudio: () => void;
    unMuteAudio: () => void;
    isVideoMuted: boolean;
    muteVideo: () => void;
    unMuteVideo: () => void;
    pause: () => void;
    resume: () => void;
    isPaused: boolean;
};

/**
 * Run a function when a component is mounted.
 *
 * @deprecated This hook breaks in React 18's strict mode, since it's not idempotent
 *
 * @param callback function to be executed
 */
declare function useMount(callback: Fn): void;

/**
 * Run a function synchronously when a component is mounted and after DOM is painted.
 *
 * @deprecated This hook breaks in React 18's strict mode, since it's not idempotent
 *
 * @param callback function to be executed
 */
declare function useMountSync(callback: Fn): void;

declare type Position = {
    x: number;
    y: number;
};
interface MouseOptions {
    /**
     * Mouse position based by page or client
     *
     * @default 'client'
     */
    type?: 'page' | 'client';
    /**
     * Listen to `touchmove` events
     *
     * @default true
     */
    touch?: boolean;
    /**
     * Reset to initial value when `touchend` event fired
     *
     * @default false
     */
    resetOnTouchEnds?: boolean;
    /**
     * Initial values
     */
    initialValue?: Position;
}
declare type MouseSource = 'mouse' | 'touch' | null;
/**
 *
 * Reactive mouse position based by page or client
 *
 * @param options
 *
 * @see https://react-hooks-library.vercel.app/core/useMouse
 */
declare function useMouse(options?: MouseOptions): {
    x: number;
    y: number;
    source: MouseSource;
};

/**
 * Watch for changes being made to the DOM tree.
 *
 * @param target - React ref or DOM node
 * @param callback - callback to execute when mutations are observed
 * @param options - Options passed to mutation observer
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver MutationObserver MDN
 * @see https://react-hooks-library.vercel.app/core/useMutationObserver
 */
declare function useMutationObserver(target: MaybeRef<Element | null | undefined>, callback: MutationCallback, options?: MutationObserverInit): {
    isSupported: boolean;
    stop: () => void;
};

declare type NetworkEffectiveType = 'slow-2g' | '2g' | '3g' | '4g' | undefined;
interface NetworkInformation extends EventTarget {
    readonly type?: ConnectionType;
    readonly effectiveType?: NetworkEffectiveType;
    readonly downlinkMax?: number;
    readonly downlink?: number;
    readonly rtt?: number;
    readonly saveData?: boolean;
    onchange?: EventListener;
}
/**
 * Reactive Network status.
 *
 * @see https://react-hooks-library.vercel.app/core/useNetwork
 */
declare function useNetwork(): {
    isSupported: boolean;
    isOnline: boolean;
    offlineAt: number | undefined;
    saveData: boolean | undefined;
    rtt: number | undefined;
    downlink: number | undefined;
    downlinkMax: number | undefined;
    effectiveType: NetworkEffectiveType;
    type: ConnectionType | undefined;
};

/**
 * Reactive online status
 *
 * @see https://react-hooks-library.vercel.app/core/useOnline
 */
declare function useOnline(): boolean;

declare type ColorSchemeType = 'dark' | 'light';
/**
 * Reactive prefers-color-scheme media query.
 *
 * @see https://react-hooks-library.vercel.app/core/usePreferredColorScheme
 */
declare function usePreferredColorScheme(): "dark" | "light";

/**
 * Returns the value of the argument from the previous render
 * @param {T} value
 * @returns {T | undefined} previous value
 * @see https://react-hooks-library.vercel.app/core/usePrevious
 */
declare function usePrevious<T>(value: T): T | undefined;

interface UseScreenShareOptions {
    /**
     * If the stream video media constraints
     *
     * @default true
     */
    video?: boolean | MediaTrackConstraints | undefined;
    /**
     * If the stream audio media constraints
     *
     * @default true
     */
    audio?: boolean | MediaTrackConstraints | undefined;
}
/**
 * Reactive screen sharing
 *
 * @param options
 *
 * @see https://react-hooks-library.vercel.app/core/useScreenShare
 */
declare function useScreenShare(options?: UseScreenShareOptions): {
    isSupported: boolean;
    isPlaying: boolean;
    ref: react.MutableRefObject<HTMLVideoElement | null>;
    stream: react.MutableRefObject<MediaStream | null>;
    play: () => Promise<MediaStream | null | undefined>;
    stop: () => void;
};

/**
 * Reactive scroll values for a react ref or a dom node
 *
 * @param target - dom node or react ref
 * @param callback - callback to run on scroll
 *
 * @see https://react-hooks-library.vercel.app/core/useScroll
 */
declare function useScroll(target: MaybeRef<Element | null | undefined>, callback: (coords: {
    scrollX: number;
    scrollY: number;
}) => void): void;

interface UseScrollIntoViewOptions extends ScrollIntoViewOptions {
    /**
     * Defines vertical alignment.
     * One of `'start'`, `'center'`, `'end'`, or `'nearest'`
     *
     * @default 'start'
     */
    block?: ScrollLogicalPosition;
    /**
     * Defines horizontal alignment.
     * One of `start`, `center`, `end`, or `nearest`. Defaults to nearest.
     *
     * @default 'nearest'
     */
    inline?: ScrollLogicalPosition;
    /**
     * Defines the transition animation.
     * One of 'auto' or 'smooth'.
     *
     * @default 'auto'
     */
    behavior?: ScrollBehavior;
    /**
     * The margin around the element to make sure it's visible.
     *
     * @default '0px'
     */
    scrollMargin?: string;
    /**
     * The condition to decide if the element should be scrolled into view.
     *
     * @default true
     */
    predicate?: boolean | (() => boolean);
}
/**
 *
 * A hook to scroll an element into view on mounting.
 *
 * @param options {UseScrollIntoViewOptions}
 *
 * @see https://react-hooks-library.vercel.app/core/useScrollIntoView
 */
declare function useScrollIntoView(target: MaybeRef<HTMLElement | null | undefined>, options?: UseScrollIntoViewOptions): void;

declare type UseSessionStorageOptions = {
    /**
     * Function for converting to string.
     *
     * @default JSON.stringify
     */
    serialize: (value: unknown) => string;
    /**
     * Function to convert stored string to object value.
     *
     * @default JSON.parse
     */
    deserialize: (value: string) => unknown;
};
/**
 * Modified `useState` hook that syncs with useSessionStorage.
 *
 * @param key
 * @param initialValue
 * @param options
 *
 * @see https://react-hooks-library.vercel.app/core/useSessionStorage
 */
declare function useSessionStorage<T>(key: string, initialValue: T, options?: UseSessionStorageOptions): [T, (value: T) => void];

declare type UseStateCompare<T> = {
    initialValue: T | (() => T);
    compare: (oldValue: T, newValue: T) => T;
};
/**
 * useState hook with custom compare function to avoid re-rendering
 * when state is the same, compares with previous state
 *
 *
 * Note: create a custom compare function, outside of the hook to keep
 * a stable reference, otherwise it will be recreated on every render
 *
 * @see https://react-hooks-library.vercel.app/core/useStateCompare
 */
declare function useStateCompare<T>({ initialValue, compare }: UseStateCompare<T>): [T, Dispatch<SetStateAction<T>>];

declare type UseStateHistoryOptions = {
    /**
     * Max number of history states to be stores
     *
     * @default 10
     */
    maxHistory?: number;
};
/**
 *
 * useState with built in undo and redo history control
 *
 * @param defaultValue
 * @param options
 * @returns
 */
declare function useStateHistory<T>(defaultValue: T | (() => T), options?: UseStateHistoryOptions): {
    state: T;
    push: (value: T) => void;
    undo: () => void;
    redo: () => void;
    reset: () => void;
    history: T[];
    redoAllowed: boolean;
};

/**
 * Reactive document title hook
 *
 * Set title or observe dom mutation reactively
 *
 * @param newTitle optional
 * @see https://react-hooks-library.vercel.app/core/useTitle
 */
declare function useTitle(newTitle?: string): {
    title: string;
    setTitle: react.Dispatch<react.SetStateAction<string>>;
};

/**
 * A state toggle hook
 *
 * @param defaultValue
 * @default false
 *
 * @see https://react-hooks-library.vercel.app/core/useToggle
 */
declare function useToggle(defaultValue?: boolean): {
    bool: boolean;
    toggle: () => void;
    setTrue: () => void;
    setFalse: () => void;
};

/**
 * Run a function when component is unmounted.
 *
 * @deprecated This hook breaks in React 18's strict mode, since it's not idempotent
 *
 * @param callback function to be executed
 */
declare function useUnMount(func: Fn): void;

interface WindowSizeOptions {
    initialWidth?: number;
    initialHeight?: number;
}
/**
 * Reactive window size.
 *
 * @param options
 *
 * @see https://react-hooks-library.vercel.app/core/useWindowSize
 */
declare function useWindowSize({ initialWidth, initialHeight }?: WindowSizeOptions): {
    width: number;
    height: number;
};

export { BreakPointHooks, BreakPointHooksReturn, ClickOutsideEvents, ClickOutsideOptions, ColorSchemeType, DocumentEventName, GeneralEventListener, IntersectionObserverOptions, KeyStrokeEventName, KeyStrokeOptions, Keys, Location, MouseOptions, MouseSource, NetworkEffectiveType, NetworkInformation, Position, UseAsyncState, UseLocalStorageOptions, UseMediaStreamOptions, UseScreenShareOptions, UseScrollIntoViewOptions, UseSessionStorageOptions, UseStateCompare, WindowEventName, WindowSizeOptions, breakpointsAntDesign, breakpointsBootstrapV5, breakpointsSematic, breakpointsTailwind, breakpointsVuetify, useActiveElement, useAsyncCallback, useClickOutside, useDebounce, useEffectAfterMount, useEventListener, useFont, useHasMounted, useHover, useIntersectionObserver, useInterval, useIsSupported, useKeyDown, useKeyPressed, useKeyStroke, useKeyUp, useLocalStorage, useLocation, useMediaQuery, useMediaStream, useMount, useMountSync, useMouse, useMutationObserver, useNetwork, useOnline, usePreferredColorScheme, usePrevious, useScreenShare, useScroll, useScrollIntoView, useSessionStorage, useStateCompare, useStateHistory, useTitle, useToggle, useUnMount, useWindowSize };
